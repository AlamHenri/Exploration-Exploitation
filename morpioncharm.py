import numpy as np
import copy
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import random


## Constante
OFFSET = 0.2
NB_PARTIES = 4000

class State:
    """ Etat generique d'un jeu de plateau. Le plateau est represente par une matrice de taille NX,NY,
    le joueur courant par 1 ou -1. Une case a 0 correspond a une case libre.
    * next(self,coup) : fait jouer le joueur courant le coup.
    * get_actions(self) : renvoie les coups possibles
    * win(self) : rend 1 si le joueur 1 a gagne, -1 si le joueur 2 a gagne, 0 sinon
    * stop(self) : rend vrai si le jeu est fini.
    * fonction de hashage : renvoie un couple (matrice applatie des cases, joueur courant).
    """
    NX,NY = None,None
    def __init__(self,grid=None,courant=None):
        self.grid = copy.deepcopy(grid) if grid is not None else np.zeros((self.NX,self.NY),dtype="int")
        self.courant = courant or 1
    def next(self,coup):
        pass
    def get_actions(self):
        pass
    def win(self):
        pass
    def stop(self):
        pass
    @classmethod
    def fromHash(cls,hash):
        return cls(np.array([int(i)-1 for i in list(hash[0])],dtype="int").reshape((cls.NX,cls.NY)),hash[1])
    def hash(self):
        return ("".join(str(x+1) for x in self.grid.flat),self.courant)
            
class Jeu:
    """ Jeu generique, qui prend un etat initial et deux joueurs.
        run(self,draw,pause): permet de joueur une partie, avec ou sans affichage, avec une pause entre chaque coup. 
                Rend le joueur qui a gagne et log de la partie a la fin.
        replay(self,log): permet de rejouer un log
    """
    def __init__(self,init_state = None,j1=None,j2=None):
        self.joueurs = {1:j1,-1:j2}
        self.state = copy.deepcopy(init_state)
        self.log = None
    def run(self,draw=False,pause=0.5):
        log = []
        if draw:
            self.init_graph()
        while not self.state.stop():
            coup = self.joueurs[self.state.courant].get_action(self.state)
            log.append((self.state,coup))
            self.state = self.state.next(coup)
            if draw:
                self.draw(self.state.courant*-1,coup)
                plt.pause(pause)
        return self.state.win(),log
    def init_graph(self):
        self._dx,self._dy  = 1./self.state.NX,1./self.state.NY
        self.fig, self.ax = plt.subplots()
        for i in range(self.state.grid.shape[0]):
            for j in range(self.state.grid.shape[1]):
                self.ax.add_patch(patches.Rectangle((i*self._dx,j*self._dy),self._dx,self._dy,\
                        linewidth=1,fill=False,color="black"))
        plt.show(block=False)
    def draw(self,joueur,coup):
        color = "red" if joueur>0 else "blue"
        self.ax.add_patch(patches.Rectangle(((coup[0]+OFFSET)*self._dx,(coup[1]+OFFSET)*self._dy),\
                        self._dx*(1-2*OFFSET),self._dy*(1-2*OFFSET),linewidth=1,fill=True,color=color))
        plt.draw()
    def replay(self,log,pause=0.5):
        self.init_graph()
        for state,coup in log:
            self.draw(state.courant,coup)
            plt.pause(pause)

class MorpionState(State):
    """ Implementation d'un etat du jeu du Morpion. Grille de 3X3. 
    """
    NX,NY = 3,3
    def __init__(self,grid=None,courant=None):
        super(MorpionState,self).__init__(grid,courant)
    def next(self,coup):
        state =  MorpionState(self.grid,self.courant)
        state.grid[coup]=self.courant
        state.courant *=-1
        return state
    def get_actions(self):
        return list(zip(*np.where(self.grid==0)))
    def win(self):
        for i in [-1,1]:
            if ((i*self.grid.sum(0))).max()==3 or ((i*self.grid.sum(1))).max()==3 or ((i*self.grid)).trace().max()==3 or ((i*np.fliplr(self.grid))).trace().max()==3: return i
        return 0
    def stop(self):
        return self.win()!=0 or (self.grid==0).sum()==0
    def __repr__(self):
        return str(self.hash())

class PuissanceQuatre(State):
    """
        On implemente le jeu de puissance 4, avec les dimensions traditionnelles de 6 lignes et 7 colonnes
    """
    NX,NY = 7,6
    def __init__(self,grid=None,courant=None):
        super(PuissanceQuatre,self).__init__(grid,courant)

    def next(self,coup):
        state = PuissanceQuatre(self.grid,self.courant)
        state.grid[coup] = self.courant
        state.courant *= -1 # Ca sera le tour au deuxieme joueur de jouer
        return state

    def get_actions(self):
        actionsPossibles = []
        for i in range(7):
            for j in range(6):
                if (self.grid[i][j] == 0):
                    actionsPossibles.append((i,j))
                    break
        return actionsPossibles

    def win(self):
        z = -self.courant # On regarde le joueur suivant
        Plate = np.zeros((self.NX + 8, self.NY + 8))
        Plate[4:4 + self.NX, 4:4 + self.NY] = self.grid
        for i in range(self.NX):
            for j in range(self.NY):
                if (Plate[i + 4, j + 4] == z):
                    streak = 1
                    for k in range(1, 4):
                        if (Plate[i + 4 + k, j + 4] == z): # On regarde si on a empilé 4 jetons
                            streak += 1
                    if (streak == 4):
                        return z
                    streak = 1
                    for k in range(1, 4):
                        if (Plate[i + 4, j + 4 + k] == z): # On regarde si on a aligné 4 jetons
                            streak += 1
                    if (streak == 4):
                        return z
                    streak = 1
                    for k in range(1, 4):
                        if (Plate[i + 4 + k, j + 4 + k] == z): # on regarde si on a une diagonale vers la droite
                            streak += 1
                    if (streak == 4):
                        return z
                    streak = 1
                    for k in range(1, 4):
                        if (Plate[i + 4 + k, j + 4 - k] == z): #on regarde si on a une diagonale vers la gauche
                            streak += 1
                    if (streak == 4):
                        return z

        return 0

    def stop(self):
        return self.win() != 0 or (self.grid == 0).sum() == 0

    def __repr__(self):
        return str(self.hash())

class Agent:
    """ Classe d'agent generique. Necessite une methode get_action qui renvoie l'action correspondant a l'etat du jeu state"""
    def __init__(self):
        pass
    def get_action(self,state):
        pass

class JoueurAlea(Agent):
    """
    On cree un joueur qui va jouer aleatoirement
    """

    def __init__(self):
        super(JoueurAlea,self).__init__()
        
    def get_action(self,state):
        actions = state.get_actions()
        return actions[random.randint(0, len(actions) - 1 )]

class JoueurMonteCarlo(Agent):
    def __init__(self,MClong):
        super(JoueurMonteCarlo,self).__init__()
        self.MClong = MClong

    def get_action(self,state):
        actions = state.get_actions()
        recomp = np.zeros(len(actions)) # on initialise le tableau de récompenses a 0

        for i in range(self.MClong):
            newState = copy.deepcopy(state) # On veut pas recopier sur les valeurs originales
            indiceNextAct = random.randint(0, len(actions) - 1)
            nextAct = actions[indiceNextAct]

            newState = newState.next(nextAct)

            J1 = JoueurAlea()
            J2 = JoueurAlea()
            Game = Jeu(newState,J1,J2)
            Winner,Log = Game.run()
            recomp[indiceNextAct] += state.courant * Winner ## On mets à jour la récompense pour la case qu'on a joue

        return actions[np.argmax(recomp)] # On retourne l'action avec la proba la plus elevee@


class JoueurUCBTree(Agent):
    def __init__(self, UCT_number =10):
        super(JoueurUCBTree, self).__init__()
        self.UCT_number = UCT_number

    def get_action(self, state):
        tree = Noeud(state)

        for i in range(self.UCT_number):
            branch = tree
            while (branch != None):
                if (branch.fils == []):
                    branch.expansion()
                    branch.developpement_noeud()
                branch = self.UCB_Tree(branch.fils)

        actions = self.UCB_Tree(tree.fils)
        return actions.coup

    def UCB_Tree(self, liste_fils):
        """On applique UCB aux Tree, fils est une list
        """
        # Initialisation
        if (liste_fils == []):
            return None
        nbWinFils = []
        nbPlayedFils= []
        for fils in liste_fils:
            nbWinFils.append(fils.nb_victoire)
            nbPlayedFils.append(fils.nb_joue)

        t = sum(nbPlayedFils)
        currentWin = []

        for i, j in zip(nbWinFils, nbPlayedFils):
            if j == 0:
                currentWin.append(9999)  # On mets un nombre tres grand puisque il n'y a aucun joueur
            else:
                currentWin.append((i / j) + np.sqrt((2 * np.log(t)) / j))
        return liste_fils[np.argmax(currentWin)]


class Noeud():
    def __init__(self, state, coup=0, pere=None):
        self.nb_victoire = 0
        self.nb_joue = 0
        self.pere = pere
        self.state = state
        self.coup = coup
        self.fils = []

    def expansion(self):
        for coup in self.state.get_actions():
            son_state = self.state.next(coup)
            self.fils.append(Noeud(son_state, coup, self))

    def developpement_noeud(self):
        """simulation"""
        # faire comme monte carlo pour avoir le developpement
        # pour chacun des fils
        for fils in self.fils:
            A = JoueurAlea()
            B = JoueurAlea()
            J = Jeu(fils.state, A, B)
            Winner, Log = J.run()
            # victoire = max(0, self.state.courant*Log[0])
            self.backpropagation(fils, Winner)

    def backpropagation(self, fils, winnerValue):
        """Donner a tous les peres de ce noeud le resultat du developpement
        """
        Noeud_courant = fils

        while (Noeud_courant != None):
            victoire = max(0, -Noeud_courant.state.courant * winnerValue)
            Noeud_courant.nb_victoire += victoire
            Noeud_courant.nb_joue += 1
            Noeud_courant = Noeud_courant.pere


#### TESTS

# TEST 1 POUR JOUEUR ALEATOIRE
"""

joueur1 = JoueurAlea()
joueur2 = JoueurAlea()

nbWinJ1 = 0
nbWinJ2 = 0
ndDraw = 0

moyenneJ1 = []
moyenneJ2 = []


for i in range(NB_PARTIES):
    plate = MorpionState()
    game = Jeu(plate,joueur1,joueur2)
    result = game.run(False)[0]
    if(result == 1) :
        nbWinJ1 += 1
    elif (result == -1):
        nbWinJ2 += 1
    else:
        ndDraw += 1
    moyenneJ1.append(nbWinJ1/float(nbWinJ1+nbWinJ2+ndDraw))
    moyenneJ2.append(nbWinJ2/float(nbWinJ1+nbWinJ2+ndDraw))
    print(nbWinJ1,nbWinJ2,ndDraw)

plt.plot(range(NB_PARTIES), moyenneJ1,label ="Esperance de J1")  # GRAPHE POUR LES JOUEURS QUI JOUENT AU HAZARD
plt.plot(range(NB_PARTIES), moyenneJ2,label ="Esperance de J2")  # GRAPHE POUR LES JOUEURS QUI JOUENT AU HAZARD

plt.legend()
plt.title("Comparaison des moyennes des deux joueurs")

plt.show()

"""

# TEST 2 : MONTE-CARLO ET ALEATOIRE
"""

J1 = JoueurMonteCarlo(20)

J2 = JoueurAlea()

nbWinJ1 = 0
nbWinJ2 = 0
nbDraw = 0

moyenneJ1 = []
moyenneJ2 = []

for i in range(NB_PARTIES):
    plate = MorpionState()
    game = Jeu(plate,J1,J2)
    result = game.run(False)[0]
    if(result == 1) :
        nbWinJ1 += 1
    elif (result == -1):
        nbWinJ2 += 1
    else:
        nbDraw += 1
    moyenneJ1.append(nbWinJ1/float(nbWinJ1+nbWinJ2+nbDraw))
    moyenneJ2.append(nbWinJ2/float(nbWinJ1+nbWinJ2+nbDraw))
    print(nbWinJ1,nbWinJ2,nbDraw)


plt.plot(range(NB_PARTIES), moyenneJ1,label ="Esperance de J1")  # GRAPHE POUR MONTE CARLO ET ALEATOIRE
plt.plot(range(NB_PARTIES), moyenneJ2,label ="Esperance de J2")  # GRAPHE POUR MONTE CARLO ET ALEATOIRE

plt.legend()
plt.title("Comparaison du joueur M-C et aleatoire")

plt.show()

"""

## TEST 3 MONTE CARLO ET MONTE CARLO

"""
J1 = JoueurMonteCarlo(20)

J2 = JoueurMonteCarlo(20)

nbWinJ1 = 0
nbWinJ2 = 0
nbDraw = 0

moyenneJ1 = []
moyenneJ2 = []

for i in range(NB_PARTIES):
    plate = MorpionState()
    game = Jeu(plate,J1,J2)
    result = game.run(True)[0]
    if(result == 1) :
        nbWinJ1 += 1
    elif (result == -1):
        nbWinJ2 += 1
    else:
        nbDraw += 1
    moyenneJ1.append(nbWinJ1/float(nbWinJ1+nbWinJ2+nbDraw))
    moyenneJ2.append(nbWinJ2/float(nbWinJ1+nbWinJ2+nbDraw))
    print(nbWinJ1,nbWinJ2,nbDraw)


plt.plot(range(NB_PARTIES), moyenneJ1,label ="Esperance de J1")  # GRAPHE POUR MONTE CARLO ET LUI MEME
plt.plot(range(NB_PARTIES), moyenneJ2,label ="Esperance de J2")  # GRAPHE POUR MONTE CARLO ET LUI MEME

plt.legend()
plt.title("Comparaison de deux joueurs M-C")

plt.show()
"""

## TEST (PUISSANCE) 4...

"""
J1 = JoueurMonteCarlo(20)
J2 = JoueurMonteCarlo(20)

nbWinJ1 = 0
nbWinJ2 = 0
ndDraw = 0

moyenneJ1 = []
moyenneJ2 = []


for i in range(NB_PARTIES):
    FourInRow = PuissanceQuatre()
    game = Jeu(FourInRow,J1,J2)
    result = game.run(True)[0]
    if(result == 1) :
        nbWinJ1 += 1
    elif (result == -1):
        nbWinJ2 += 1
    else:
        ndDraw += 1
    moyenneJ1.append(nbWinJ1/float(nbWinJ1+nbWinJ2+ndDraw))
    moyenneJ2.append(nbWinJ2/float(nbWinJ1+nbWinJ2+ndDraw))
    print(nbWinJ1,nbWinJ2,ndDraw)

plt.plot(range(NB_PARTIES), moyenneJ1,label ="Esperance de J1")  # GRAPHE POUR LES JOUEURS QUI JOUENT AU HAZARD
plt.plot(range(NB_PARTIES), moyenneJ2,label ="Esperance de J2")  # GRAPHE POUR LES JOUEURS QUI JOUENT AU HAZARD

plt.legend()
plt.title("Comparaison des moyennes des deux joueurs")

plt.show()
"""

# TEST 5 : UCB ET ALEA


J1 = JoueurUCBTree(10)

J2 = JoueurAlea()

nbWinJ1 = 0
nbWinJ2 = 0
nbDraw = 0

moyenneJ1 = []
moyenneJ2 = []

for i in range(NB_PARTIES):
    plate = MorpionState()
    game = Jeu(plate,J1,J2)
    result = game.run(False)[0]
    if(result == 1) :
        nbWinJ1 += 1
    elif (result == -1):
        nbWinJ2 += 1
    else:
        nbDraw += 1
    moyenneJ1.append(nbWinJ1/float(nbWinJ1+nbWinJ2+nbDraw))
    moyenneJ2.append(nbWinJ2/float(nbWinJ1+nbWinJ2+nbDraw))
    print(nbWinJ1,nbWinJ2,nbDraw)


plt.plot(range(NB_PARTIES), moyenneJ1,label ="Esperance de UCB")  # GRAPHE POUR UCB ET ALEATOIRE
plt.plot(range(NB_PARTIES), moyenneJ2,label ="Esperance de Alea")  # GRAPHE POUR UCB ET ALEATOIRE

plt.legend()
plt.title("Comparaison du joueur UCB et aleatoire")

plt.show()
